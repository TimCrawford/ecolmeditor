<!DOCTYPE html>
<html>
<head>
<title>Read MIDI File</title>
<script 	src="https://unpkg.com/@tonejs/midi" ></script>
<!-- 
<script 	src="Midi.js" ></script>
 -->
	


<script>
/*This script reads a MIDI file of a lute piece transcribed in Sibelius and outputs TabCode.
  It probably will fail with any other MIDI files, and certainly with non-lute music 
  (though it may generate some kind of 'intabulation')
*/

// global variables
	var orig_filename = "";
	var allnotes = [];
	var totalDur = 0;
	var PPQ = 480;
	var BPM = 120;
	var lastNoteStart = 0;
	var lastNoteEnd = 0;
	var timeSigNum = 4;
	var timeSigDenom = 4;
	var timeSig = "";
// 	var key = "";
	var barcount = 1;
	
	var MAXCHORDSPERSYSTEM = 30;	
	var TabLetter = [];
	var tabcode = [];
	var lastChord = "";
	
	var theTuning = [];
	var gcurrentstring = 0;

	var rhythmSymbol = [];
	
	var ren_rules = "{<rules>\n<tuning_named>renaissance</tuning_named>\n<rhythm-font>varietie</rhythm-font>\n<pitch>67</pitch>\n<bass_tuning>(-2 -1 -2 -2 -1 -2 -2 -2 )</bass_tuning>\n</rules>}";
	var bar_rules = "<rules>\n<tuning_named>baroque</tuning_named>\n<rhythm-font>weiss</rhythm-font>\n<pitch>65</pitch>\n<bass_tuning>(-2 -2 -1 -2 -2 -2 -1 -2  )</bass_tuning>\n</rules>}";	
	var majorKeys = [];
	var minorKeys = [];
	
	var bar_bassrules = [];
	var ren_bassrules = [];
	var bassrules = "";
	var key = 0;

// Functions

function makeRules(tuning_name, keysig_accids) {
	var rules = "{<rules>\n<tuning_named>";
	rules += (tuning_name == "renaissance")? tuning_name : "baroque";
	rules += "</tuning_named>\n<rhythm-font>";
	rules += (tuning_name == "renaissance")? "varietie" : "weiss";
	rules += "</rhythm-font>\n<pitch>";
	rules += (tuning_name == "renaissance")? "67" : "65";
	rules += "\n<bass_tuning>(";
	if(tuning_name == "renaissance") {
	bassrules = ren_bassrules[keysig_accids+7];
	}
	else {
	bassrules = bar_bassrules[keysig_accids+7];
	}
	rules += bassrules;
	rules += ")</bass_tuning>\n</rules>}";
	return rules;
}

// Initialise
function initialiseTabStuff(resolution, tuning) {
	resolution *= 2; // ????
	
	var Wlength = resolution * 4;
	var Hlength = resolution * 2;
	var Qlength = resolution ;
	var Elength = resolution / 2;
	var Slength = resolution / 4;
	var Tlength = resolution / 8;
	var Ylength = resolution / 16;
	var Zlength = resolution / 32;
	
	rhythmSymbol[Zlength] = "Z";
	rhythmSymbol[Zlength*3/2] = "Z.";
	rhythmSymbol[Ylength] = "Y";
	rhythmSymbol[Ylength*3/2] = "Y.";
	rhythmSymbol[Tlength] = "T";
	rhythmSymbol[Tlength*3/2] = "T.";
	rhythmSymbol[Slength] = "S";
	rhythmSymbol[Slength*3/2] = "S.";
	rhythmSymbol[Elength] = "E";
	rhythmSymbol[Elength*3/2] = "E.";
	rhythmSymbol[Qlength] = "Q";
	rhythmSymbol[Qlength*3/2] = "Q.";
	rhythmSymbol[Hlength] = "H";
	rhythmSymbol[Hlength*3/2] = "H.";
	rhythmSymbol[Wlength] = "W";
	rhythmSymbol[Wlength*3/2] = "W.";
	
	TabLetter = "abcdefghiklmnop".split("");

	BarTuning = "65,62,57,53,50,45,43,41,40,38,36,35,33".split(",");
	RenTuning = "67,62,57,53,48,43,41,40,38,36,35,33,31".split(",");
	
	// change default tuning here! (Temporary)
	for(i=0;i<=BarTuning.length-1;i++) {
		theTuning[i] = tuning=="baroque"? BarTuning[i] : RenTuning[i] ;
	}
	
	majorKeys["C"]=0;
	majorKeys["C#"]=7;
	majorKeys["D"]=2;
	majorKeys["Eb"]=-3;
	majorKeys["E"]=4;
	majorKeys["F"]=-1;
	majorKeys["F#"]=6;
	majorKeys["G"]=1;
	majorKeys["Ab"]=-4;
	majorKeys["A"]=3;
	majorKeys["Bb"]=-2;
	majorKeys["B"]=5;

	minorKeys["C"]=-3;
	minorKeys["C#"]=4;
	minorKeys["D"]=-1;
	minorKeys["Eb"]=-6;
	minorKeys["E"]=1;
	minorKeys["F"]=-4;
	minorKeys["F#"]=3;
	minorKeys["G"]=-2;
	minorKeys["G#"]=5;
	minorKeys["A"]=0;
	minorKeys["Bb"]=-5;
	minorKeys["B"]=2;
	
	ren_bassrules[0] = "-3 -1 -2 -2 -2 -2 -2 -2";
	ren_bassrules[1] = "-2 -2 -2 -2 -1 -2 -2 -1";
	ren_bassrules[2] = "-2 -2 -2 -1 -2 -2 -2 -1";
	ren_bassrules[3] = "-2 -2 -2 -1 -2 -2 -1 -2";
	ren_bassrules[4] = "-2 -2 -1 -2 -2 -2 -1 -2";
	ren_bassrules[5] = "-2 -2 -1 -2 -2 -1 -2 -2";
	ren_bassrules[6] = "-2 -1 -2 -2 -2 -1 -2 -2";
	ren_bassrules[7] =  "-2 -1 -2 -2 -1 -2 -2 -2";
	ren_bassrules[8] =  "-1 -2 -2 -2 -1 -2 -2 -1";
	ren_bassrules[9] =  "-1 -2 -2 -1 -2 -2 -2 -1";
	ren_bassrules[10] =  "-1 -2 -2 -1 -2 -2 -1 -2";
	ren_bassrules[11] =  "-1 -2 -1 -2 -2 -2 -1 -2";
	ren_bassrules[12] =  "-1 -2 -1 -2 -2 -1 -2 -2";
	ren_bassrules[13] =  "-1 -1 -2 -2 -2 -1 -2 -2";
	ren_bassrules[14] =  "-1 -1 -2 -2 -1 -2 -2 -2";

	bar_bassrules[0]  = "-3 -2 -1 -2 -2 -1 -2 -2";
	bar_bassrules[1]  = "-3 -1 -2 -2 -2 -1 -2 -2";
	bar_bassrules[2]  = "-3 -1 -2 -2 -1 -2 -2 -2";
	bar_bassrules[3]  = "-2 -2 -2 -2 -1 -2 -2 -1";
	bar_bassrules[4]  = "-2 -2 -2 -1 -2 -2 -2 -1";
	bar_bassrules[5]  = "-2 -2 -2 -1 -2 -2 -1 -2";
	bar_bassrules[6]  = "-2 -2 -1 -2 -2 -2 -1 -2";
	bar_bassrules[7] =  "-2 -2 -1 -2 -2 -1 -2 -2";
	bar_bassrules[8] =  "-2 -1 -2 -2 -2 -1 -2 -2";
	bar_bassrules[9] =  "-2 -1 -2 -2 -1 -2 -2 -2";
	bar_bassrules[10] =  "-1 -2 -2 -2 -1 -2 -2 -2";
	bar_bassrules[11] =  "-1 -2 -2 -1 -2 -2 -2 -1";
	bar_bassrules[12] =  "-1 -2 -2 -1 -2 -2 -1 -2";
	bar_bassrules[13] =  "-1 -2 -1 -2 -2 -2 -1 -2";
	bar_bassrules[14] =  "-1 -2 -1 -2 -2 -1 -2 -2";

}

function AdjustKey(NumofAccs, tuning_type) // for now, tuning_type is "renaissance" or "baroque"
{
//console.log(NumofAccs)
//console.log(theTuning)
	
	rules = makeRules(tuning_type, NumofAccs);

//console.log(tabcode)
	
	var accsequence = [];
	
	if(NumofAccs>0) sharps = true;
	else sharps = false;
	accsequence[1] = 11;
	accsequence[2] = 8;
	accsequence[3] = 12;
	accsequence[4] = 9;
	accsequence[5] = 6;
	accsequence[6] = 10;
	accsequence[7] = 7;
	j = 1;
	if (!sharps) {
		while (j <= (-1 * NumofAccs)) {
			i = accsequence[j]-1;
			theTuning[i]--;
			j++;
		}
	}
	else {
		while (j <= (NumofAccs)) {
			i = accsequence[8 - j]-1;
			theTuning[i]++;
			j++;
		}
	}
	theTuning[12] = theTuning[6] - 12;  // set bottom octave GG 
//	console.log(theTuning)
}

function MIDItoTabNote (note) {
	FretNum = 0;
	slashnumber = 0;
	ondiapason = 0;
	finished = 0;
	theNote = 0;
	k = gcurrentstring;
	theNote = note;
//console.log(barcount+": "+theNote)
		
	while ((k< 13)&&(!finished))	{
		FretNum = theNote - theTuning[k] ;
		if (FretNum>=0) {
			if (FretNum>14)   /* we're off the top! */	{
				tabcode.push("{MIDI "+theNote+" is out of range of string "+(k+1)+"}");
				console.log("Bar "+barcount+": MIDI "+theNote+" is out of range of string "+(k+1));
				finished = 1;
				return ;
			}
			else {
				if (k>6)   /* we're on the diapasons */ {
					ondiapason = 1;
					slashnumber = k - 7;
				}
			}
			finished = 1;
		}
		k++;
	}
	
	if(ondiapason)	{	
		var slashstring="";
		j = 0;
		if ((slashnumber < 4)&&(slashnumber >= 0))	{
			for(m=0; m<=slashnumber; m++) slashstring += "/";
			lastChord = tabcode[tabcode.length-1] + "X"+TabLetter[FretNum]+slashstring;
			tabcode[tabcode.length-1] = lastChord;
		}
		else if (slashnumber > 3 )	{
				lastChord = tabcode[tabcode.length-1] + "X"+(slashnumber);
				tabcode[tabcode.length-1] = lastChord;
			}
	}
	else	{
		lastChord = tabcode[tabcode.length-1] + TabLetter[FretNum]+(k);
		tabcode[tabcode.length-1] = lastChord;
	}
		gcurrentstring = k;
//console.log("\t"+tabcode[tabcode.length-1])
		return;
}
var		allnotes = [];

	function getMIDI(url) {
		
		var midi = new Midi();
		var notes = [];

		// load a midi file in the browser
		Midi.fromUrl(url).then(midi => {
			//get the header
			PPQ = midi.header.ppq;
			BPM = midi.header.tempos[0].bpm;
			initialiseTabStuff(PPQ, "renaissance");
			timeSigNum = midi.header.timeSignatures[0].timeSignature[0];
			timeSigDenom = midi.header.timeSignatures[0].timeSignature[1];
			timeSig = timeSigNum+"/"+timeSigDenom;
			key = midi.header.keySignatures[0].key;

	console.log(midi)
	console.log("key = "+key)
	console.log("Time Sig: "+timeSig)

			AdjustKey(midi.header.keySignatures[0].scale == "major"? majorKeys[midi.header.keySignatures[0].key] : minorKeys[midi.header.keySignatures[0].key], "renaissance");

			totalDur = ((midi.duration ))
		
			//get the tracks
			midi.tracks.forEach(track => {
			  //Get all notes from all tracks
				notes = track.notes;
				notes.forEach(note => {
					allnotes.push([note.ticks,note.midi]);
				})
			})
document.getElementById("msg").innerHTML = "&nbsp;&nbsp;<small>(" + allnotes.length + " notes)</small>"
			// For TabCode we need *all* sounding notes grouped in their chords in a single time-sequence.
			//notes from different tracks will not be in time-order!! So:
			allnotes.sort(function (a,b) {
				if(a[0]>b[0]) return 1;
				if(a[0]<b[0]) return -1;
				if(a[1]<b[1]) return 1;
				if(a[1]>b[1]) return -1;
				return 0;
			});
if(document.getElementById(key))		document.getElementById(key).selected = true;
console.log("key = "+key)
if(document.getElementById(timeSig))		document.getElementById(timeSig).selected = true;
console.log("Time Sig: "+timeSig)
		});
		document.getElementById("showButton").hidden = false;
		document.getElementById("controls").hidden = false;
		
if(document.getElementById(key))		document.getElementById(key).selected = true;
console.log("key = "+key)
if(document.getElementById(timeSig))		document.getElementById(timeSig).selected = true;
console.log("Time Sig: "+timeSig)
		
	}
	function tempPath(file_obj) {
		orig_filename = file_obj.name;
		var path = URL.createObjectURL(file_obj);
		return path;
	}
	function printNotes() {
	console.log("Printing notes:")
		var notecount = 0;
		var lastTicks = 0;
		for(i=0;i<=allnotes.length-1;i++) {
			notecount++;
			lastTicks = allnotes[i][0];
		}
	}
	function ticksToBeat(ticks) {
		return (ticks/60)/16;
	}
	function lastNotes() {
		lastNoteStart = allnotes[allnotes.length - 1][0]/PPQ;
		lastNoteEnd = (totalDur/60)*BPM
		console.log("Last note starts at "+(lastNoteStart) + " beats")
		console.log("... and ends at " + lastNoteEnd+" beats")
		console.log("... Its duration is "+(lastNoteEnd-lastNoteStart)+" beats")
		
	}
	function notesToTabcode() {
		var beatcount = 0;
		var lastTicks = -1;
		var systemcount = 1;
		var chordcount = 0;
		var chordDur = 0;
		var beatsInBar = timeSigNum*(4/timeSigDenom);
		var needSystemBreak = false;

// 		This doesn't seem to work. Why??
		// Clear old tabcode from everywhere:
		var tabcodestring = "";
		tabcode.length = 0;
		document.getElementById("display").innerHTML="";
		barcount = 1;
				
		for(i=0;i<=allnotes.length-1;i++) {
			beatcount = ticksToBeat(allnotes[i][0]);
			
			// Check to see if the last chord we did is now complete:
			if(allnotes[i][0] > lastTicks) {
				chordcount++;
				gcurrentstring = 0;
				chordDur = allnotes[i][0] - lastTicks;
				if(tabcode.length) {
					if(tabcode[tabcode.length-1].slice(1,2) != "|") {
						lastChord = rhythmSymbol[chordDur*2] + tabcode[tabcode.length-1];
						tabcode[tabcode.length-1] = lastChord;
					}
				}
				tabcode.push("");
			}
			if(beatcount && (allnotes[i][0] > lastTicks)) if(beatcount%beatsInBar==0) {
				barcount++;
				tabcode.push("| {bar "+barcount+"}");
				tabcode.push("");
				// Enter system break if necessary after barline:
				if(needSystemBreak) {
					tabcode.push("{^} {System "+systemcount+"}");
					tabcode.push("");
					needSystemBreak = false;
					chordcount = 0;
				}
			}
			// Check to see if we need a system break:
			if(chordcount&&(chordcount%MAXCHORDSPERSYSTEM == 0)) {
				// Make sure that we haven't just put in a system break:
				if(tabcode[tabcode.length-2].slice(0,3) != "{^}")	{
	// 				console.log("{System Break near here!!}")
					systemcount++;
					needSystemBreak = true;
					}
			}

			MIDItoTabNote(allnotes[i][1]);
			lastTicks = allnotes[i][0];
		}
		chordDur = ((totalDur/60)*BPM*PPQ) - lastTicks;
		if(tabcode.length && (tabcode[tabcode.length-1].slice(1,2) != "|")) {
			lastChord = rhythmSymbol[chordDur*2] + tabcode[tabcode.length-1];
			tabcode[tabcode.length-1] = lastChord;
		}
		tabcode.push("");
		
		// Insert initial time-signature. NB FIXME - doesn't handle changes during a piece!!
		tabcode.unshift("");
		var timesig_code = (timeSig != "")? timeSig : timeSigNum+":"+timeSigDenom;
		tabcode.unshift("M("+timesig_code+")")

		tabcode.unshift(rules); //Need to be absolutely first!
		tabcodestring += "\n\n" + tabcode.join("\n");
	
		document.getElementById("display").innerHTML=tabcodestring;
		document.getElementById("display").hidden=false;
		document.getElementById("display").select();
		document.getElementById("display").focus();

		// Next line puts tabcodestring on the system clipboard ready for pasting! Cool! But only use for testing!!:
//		navigator.clipboard.writeText(tabcodestring);				
	}
function getSelectedTimeSig() {
	timeSig = document.getElementById("timesig_choice").value;
	console.log("Time sig changed to "+timeSig)
}
function getSelectedKey() {
	console.log(document.getElementById("key_choice").value+" selected")	
	key = document.getElementById("key_choice").value.split("/")[0];
	console.log("Key changed to "+key)
	AdjustKey(majorKeys[key])
}
</script>
</head>

<body>
	<h2>Read MIDI from file:</h2>
	<p><input type=file id="file" size=80 onchange='getMIDI(tempPath(this.files[0]));'>

	<span id="msg"></span>
	<div id="controls" hidden>
		Choose time-signature:<select id="timesig_choice" onchange="getSelectedTimeSig()">
			<option id="C">C</option>
			<option id="C/">C/</option>
			<option id="4/4">4/4</option>
			<option id="3/4">3/4</option>
			<option id="2/4">2/4</option>
			<option id="2/2">2/2</option>
			<option id="3/2">3/2</option>
			<option id="4/2">4/2</option>
			<option id="6/8">6/8</option>
			<option id="12/8">12/8</option>
		</select>
		Choose key:<select id="key_choice" onchange="getSelectedKey()">
			<option id="C">C/a</option>
			<option id="F">F/d</option>
			<option id="Bb">Bb/g</option>
			<option id="Eb">Eb/c</option>
			<option id="G">G/e</option>
			<option id="D">D/b</option>
			<option id="A">A/f#</option>
			<option id="E">E/c#</option>
			<option id="Ab">Ab/f</option>
			<option id="Db">Db/bb</option>
			<option id="B">B/g#</option>
			<option id="Gb">Gb/eb</option>
		</select>
	</div>
	<button id="showButton" hidden onclick="notesToTabcode();">Import</button></p>
	<textarea id="display" hidden rows="30" overflow-y="scroll"></textarea>
</body>
</html>